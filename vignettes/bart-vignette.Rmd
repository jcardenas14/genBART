---
title: "BART package Vignette"
author: "Jacob Cardenas"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BART package Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

BART is a user friendly, point and click, R shiny application that was developed as a biostatistical reporting tool for a broad range of high throughput experiments such as RNA sequencing, Microarray, and Flow Cytometry. BART provides users with the ability to interactively view and download (all tables and figures generated by the app) the entire analysis workflow:

- Design file summary statistics 
- Quality control metrics 
- Unsupervised Analysis (heatmaps and clustering)
- Differential gene expression (easily sortable genelists, venn diagrams)
- Gene set analysis 

To make the tools that BART offers more readily available, we introduce the BART package, a series of functions that transforms R objects generated from modeling packages limma and DESeq2 into files that can then be uploaded into BART. In the following sections, we illustrate how to use the functions available in BART by walking through the analysis of the Flu microarray dataset using limma. The Flu expression and design files are available in the BART package. 

## Sample limma Analysis

This is a quick walkthrough of an analysis in limma. The example we are using comes from a study in which 17 healthy human subjects were exposed to the influenza virus. Data measurements were taken at baseline (before exposure) and at 14 additional unequally spaced timepoints up to 108 hours after exposure. Each subject was identified as symptomatic or asymptomatic to the exposure. For more details about modeling in limma, refer to the limma User's Guide.

```{r}
library(genBART)
library(limma)
```
Create a grouping factor by combining responder status and time point. 
```{r}
tb.design$Group <- paste(tb.design$clinical_status,tb.design$mytimepoint,sep = "")
grp <- factor(tb.design$Group)

```
Create a design matrix that includes separate coefficients for each level within the grouping factor so that the desired differences can be extracted as contrasts.
```{r}
design2 <- model.matrix(~0+grp)
colnames(design2) <- levels(grp)
```
Since there are repeated measurements on each subject, we treat Subject as a random effect and estimate the correlation between measurements on the same subject. In limma, this is done using duplicateCorrelation.
```{r}
dupcor <- duplicateCorrelation(tb.expr, design2, block = tb.design$monkey_id)
```
Fit model and extract contrasts of interest.
```{r}
fit <- lmFit(tb.expr, design2, block = tb.design$monkey_id, correlation = dupcor$consensus.correlation)
contrasts <- makeContrasts(A_3vsPre = Active3-Active0,A_7vsPre = Active7-Active0, A_10vsPre = Active10-Active0,A_20vsPre = Active20-Active0,
                           A_30vsPre = Active30-Active0,A_42vsPre = Active42-Active0,A_56vsPre = Active56-Active0,A_M3vsPre = Active90-Active0,
                           A_M4vsPre = Active120-Active0,A_M5vsPre = Active150-Active0,A_M6vsPre = Active180-Active0,L_3vsPre = Latent3-Latent0,
                           L_7vsPre = Latent7-Latent0, L_10vsPre = Latent10-Latent0,L_20vsPre = Latent20-Latent0,L_30vsPre = Latent30-Latent0,
                           L_42vsPre = Latent42-Latent0,L_56vsPre = Latent56-Latent0,L_M3vsPre = Latent90-Latent0,L_M4vsPre = Latent120-Latent0,
                           L_M5vsPre = Latent150-Latent0,L_M6vsPre = Latent180-Latent0,ALcom_3vsPre = ((Active3+Latent3)/2)-((Active0+Latent0)/2), 
                           ALcom_7vsPre = ((Active7+Latent7)/2)-((Active0+Latent0)/2),ALcom_10vsPre = ((Active10+Latent10)/2)-((Active0+Latent0)/2),
                           ALcom_20vsPre = ((Active20+Latent20)/2)-((Active0+Latent0)/2),ALcom_30vsPre = ((Active30+Latent30)/2)-((Active0+Latent0)/2),
                           ALcom_42vsPre = ((Active42+Latent42)/2)-((Active0+Latent0)/2),ALcom_56vsPre = ((Active56+Latent56)/2)-((Active0+Latent0)/2),
                           ALcom_M3vsPre = ((Active90+Latent90)/2)-((Active0+Latent0)/2),ALcom_M4vsPre = ((Active120+Latent120)/2)-((Active0+Latent0)/2),
                           ALcom_M5vsPre = ((Active150+Latent150)/2)-((Active0+Latent0)/2),ALcom_M6vsPre = ((Active180+Latent180)/2)-((Active0+Latent0)/2),
                           AvsL_Pre = Active0-Latent0,AvsL_3 = Active3-Latent3,AvsL_7 = Active7-Latent7,AvsL_10 = Active10-Latent10,AvsL_20 = Active20-Latent20,
                           AvsL_30 = Active30-Latent30,AvsL_42 = Active42-Latent42, AvsL_56 = Active56-Latent56, AvsL_M3 = Active90-Latent90,
                           AvsL_M4 = Active120-Latent120, AvsL_M5 = Active150-Latent150,AvsL_M6 = Active180-Latent180,levels=design2)

fit2 <- contrasts.fit(fit, contrasts)
fit2 <- eBayes(fit2, trend = FALSE)

```
## Design Information

After running the analysis, the first step in generating a BART ready file is to define the elements of the design file. Keep in mind that not every one of these elements is necessary for the rest of the BART functions to run, so in practice, much of this section is left to user discretion and the particular project at hand.

Below are the first six lines of the design file from the influenza study.
```{r}
head(tb.design)
```
We will walk through the different elements that the BART function `designInfo` is expecting the user to define, as well as where and how these elements are used in the BART shiny app: 

###### Necessary 
1. ```design``` - The design file. Needed to annotate, sort, and subset the heat maps. Additionally, the first tab in the BART app displays a searchable and sortable design file.
2. ```columnname``` - The column in the design file that contains the same sample names as the columns of the expression file. In particular, this element is important for the heatmaps because it ensures that the design file and expression files align correctly. If your design file does not have such a column, add it to your design. Defaults to ```NULL```.
3. ```longitudinal``` - This is a ```TRUE``` or ```FALSE``` entry depending on the study design. It determines the different types of heat maps that are made. For example, if ```TRUE```, a baseline subracted heat map is generated. Defaults to ```FALSE```.
4. ```patientID``` - The name of the the column in the design file that identifies the individual patients. This is useful for labeling and subsetting the heat maps. Defaults to ```NULL```.
5. ```baselineVariable``` - This is usually the "time" column in the design file. If the study is not longitudinal and there is no column for time then there is no need to fill out this option. Defaults to ```NULL```.
6. ```baselineValue``` - The value in the "time" column that corresponds to baseline (often 0). Defaults to ```NULL```.
7. ```controlVariable``` - This is usually the column in the design file that identifies the patient groupings. Defaults to ```NULL```.
8. ```controlValue``` - The value in the control variable column that specifies a control. If specified, a "healthy normalized" heat map will be generated. Defaults to ```NULL```.

###### Not Necessary but Useful
9. ```timeVariable``` - If ```longitudinal = TRUE```, the column in the design file that corresponds to time. Often the same as baselineVariable. Default is ```NULL```.
10. ```responderVariable``` - Usually the column in the design file that identifies the patient groups. Often the same as controlVariable. Default is ```NULL```.
11. ```summaryVariable``` - Often a numeric column in the design file that may be useful to view summary stats on. Age is often used. Default is ```NULL```.
12. ```sampleID``` - The column in the design file that uniquely identifies each individual sample. In contrast to patientID, sampleID will have a unique id for each time point of an individual patient. 

###### Completely Optional
13. ```projectName``` - This can be a string of whatever you want. In BART, the project name will appear on the first page of the app upon uploading the BART files.

For the influenza study, the function call is:
```{r}
des.info <- desInfo(y = tb.expr, design = tb.design, data_type = "micro", columnname = "columnname", long = TRUE, patient_id = "monkey_id", 
                       baseline_var = "mytimepoint", baseline_val = 0, time_var = "mytimepoint", responder_var = "clinical_status", 
                       summary_var = "numbChip", sample_id = "sample_group", project_name = "Jason_TB")
```


## Generate Model Results File
The next step in the process is to generate a model results file that is formatted specifically for BART. This can be done by using the `genModelResults` function. We walk through the function parameters below:

1. ```y``` - expression dataset where the rows are genes and columns are samples. 
2. ```object``` - The final results object containing the comparisons of interest generated from limma or DESeq2.
3. ```lm.Fit``` - The initial fit estimating the group means. This is used to compute the residuals.
4. ```method``` - One of either "limma" or "DESeq2".
5. ```comparison_names``` - An optional vector of comparison names if not already named when doing the analysis. Defaults to ```NULL```.
6. ```gene_names``` - An optional vector of gene names if the expression set has no rownames. Defaults to ```NULL```.
7. ```gene_symbols``` - An optional vector of gene symbols. Defaults to ```NULL```.


```{r}
mod_results <- genModelResults(design_info = des.info, object = fit2, lm_Fit = fit, method = "limma")
```


## Clustering (Generate Dendrograms)

Next we move on to generating dendrograms from hierarchical clustering. This step is necessary to produce the heat maps that can be viewed and downloaded in BART. This can be done through the `genDendrograms` function, which takes only two parameters as inputs. 

1. ```y``` - expression dataset where rows are genes and columns are samples.
2. ```design_info``` - The object generated from `designInfo`.

```
dendros <- genDendrograms(y = flu_data, design.info = des.info)
```

## Gene Set Analysis

Next we run gene set analysis by incorporating functions available in the qusage package. The function `geneSetTesting` simplifies the process by requiring only two input parameters.

1. ```object``` - The model results object generated from `genModelResults`.
2. ```gene_sets``` - A list of gene sets.

```
gene.set.test <- geneSetTesting(object = mod_results, gene_sets = genesets)
```

## Correlations
In addition to providing tools for the standard analysis workflow, BART also offers a tool that allows users to visualize and sort through potentially hundreds of thousands pairwise correlations between clinical outcomes. The `crossCorr` function takes two matrices of outcomes and outputs a long format file of all their pairwise correlations. The input parameters are described below.

1. ```x``` - A numeric matrix or dataframe in which the columns are variables. Optional grouping column (i.e. time in longitudinal setting).
2. ```y``` - A second matrix or dataframe with the same number of rows as x
3. ```by```- Defualt is set to NA. If grouping column in x exists, set `by` equal to its columnname.
4. ```method``` - Default is set to "pearson". The alternatives are "spearman" and "kendall".
5. ```description``` - Description of what's being correlated. Default is "X vs Y". Can be any string.
6. ```xvar``` - Description of variables in x matrix. Default is "X". Can be any string.
7. ```yvar``` - Description of variables in y matrix. Default is "Y". Can be any string.
8. ```order.by``` - Order output file by p-value (p) or correlation value (r). Defualt is set to "p" and alternative is "r".
9. ```decreasing``` - Default is TRUE. If FALSE, then the ordering is from smallest to largest.

We walk through an example in which we wish to correlate Baylor modules with probes from the flu dataset that we have been working with. Since module scores are calculated as percentages up or down relative to the mean of the baseline samples, we subtract the mean of the baseline samples from the probes before correlating. For the purposes of this tutorial, we randomly selected 500 probes to correlate with 259 Baylor modules (one of them had zero standard deviation so we threw it out). Since this is a longitudinal setting, we correlate by time.

```
# Add grouping column to module matrix. We don't include baseline since it has been subtracted out.

mods$Hours <- design$Hours[-which(design$Hours == 0)]
corrs <- crossCorr(x = mods, y = exp, by = "Hours", description = "Modules vs Probes", xvar = "Modules", yvar = "Probes")

```

## Generate BART file

The last step in the process is to generate the final file that can be uploaded into BART. This is done through the function `genBartFiles`, which takes as its arguments the objects generated from the previous functions. Conveniently, not every object is required to generate a BART file. For example, if for some reason gene set analysis was not run, the `designInfo`, `genModelResults`, and `genDendrograms` objects can still be run through `genBartFiles`. The BART app will only show the results that are uploaded in.

```
genFile(y = tb.expr, design.info = des.info, modelResults = mod_results, dendrograms = dendros, geneSetTest = gene.set.test, corr = corrs, Illumina = FALSE)
```



