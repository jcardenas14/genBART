---
title: "genBART package Vignette"
author: "Jacob Cardenas"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{genBART package Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library(genBART)
library(limma)
```

BART (Biostatistical Analysis Reporting Tool) is a user friendly, point and click, R shiny application. With the genBART package, Biostatisticians/bioinformaticians analyze high throughput biological data obtained from RNA Seq, Microarray, Flow Cytometry experiments and upload the result into BART. The tool allows the R programmer who conducted the analysis and their colleagues to efficiently examine the results. BART provides users the ability  to easily view, modify and download the tables and figures generated by the app. BART offers one reporting source for all analyses in a project workflow.

- Sample information (e.g. technical, biological, clinical, and demographics) summary  statistics
- Sample quality control metrics
- Unsupervised analysis (heatmap and cluster analysis)
- Differential expression (sortable genelists, venn diagrams)
- Gene set analysis
- Correlation analysis within and between biological data types


So that BART is readily available, we introduce the genBART package. genBART is a series of functions that transforms R objects generated from statistical and modeling packages such as limma, DESeq2, and edgeR into files that are uploaded into BART. In the following sections, we illustrate how to use the functions available in genBART by walking through the analysis of a longitudinal microarray study tracking gene expression changes in 38 healthy cynomolgus macaques infected with *M. tuberculosis* [(Skinner et al.)](http://www.jimmunol.org/content/197/12/4817.long). Briefly, this study consisted of data measurements taken at baseline (before infection) and at 11 additional timepoints, up to 6 months post infection. Each macaque was identified as developing symptomatic (active) TB or asymptomatic (latent) infection. For the purposes of illustration and time, a subset of the microarray data was chosen for analysis. We randomly selected 4000 probes and 10 macaques and include 3 time points (days 0, 20, and 42). For the flow, data was collected on 19 of the 38 macaques and 13 variables are analyzed. In addition to microarray data, the study also has flow data that will be incorporated to demonstrate the flexibility of the BART app.

\vspace{12pt}
\begin{center} \large{\textbf{Summary of genBART package}} \end{center}

| Function            | Purpose                                                                               |
|:--------------------|:--------------------------------------------------------------------------------------|
| `desInfo()`         | Aligns design and expression files. Defines elements of design for further analyses.    |    
| `genDendrograms()`  | Normalizes and clusters expression data                                               |
| `genModules()`      | Generates gene set maps for plotting.                                                  |
| `genModelResults()` | Processes and formats differential expression modeling results.                       |
| `qBart()|rBart()`   | Runs gene set analysis using QuSAGE or ROAST algorthms.                               |
| `crossCorr()`       | Runs pairwise correlations between two data sets (e.g. flow cytometry and microarray).|
| `genFile()`         | Generates and saves BART ready .rda file.                                             |
| `updateFile()`      | Updates/adds analyses to existing BART file.                                          |
| `runBart()`         | Runs BART shiny app.                                                                  |

Table: Functions in the genBART package ordered to demonstrate a typical analysis workflow.

The genBART package contains 10 functions, each of which is listed in the table above. Greater detail on each of these functions, their parameters, and how they are integrated into a typical workflow is available via the help commands in R. 

\vspace{12pt}
\begin{center} \large{\textbf{Design Information}} \end{center}

Before running any analysis, the first step in generating a BART ready file is to define the elements of the design file and sample information. Keep in mind that not every one of these elements is necessary for the rest of the genBART functions to run, so in practice, much of this section is left to user discretion and the particular project at hand.

```
library(genBART)
library(limma)
```

Below are the first six lines of the design file from the TB microarray study described in the introduction.
```{r}
head(tb.design)
```

For this study, the function call would be:
```{r}
des.info <- desInfo(y = tb.expr, design = tb.design, data_type = "micro", 
                    columnname = "columnname", long = TRUE, 
                    sample_id = "sample_id", patient_id = "monkey_id", 
                    time_var = "timepoint", baseline_var = "timepoint", baseline_val = 0, 
                    summary_var = NULL, responder_var = "clinical_status",  
                    project_name = "TB")
```

We proceed similarly for the flow data:
```{r}
des.info.flow <- desInfo(y = tb.flow, design = tb.flow.des, data_type = "flow", 
                         columnname = "columnname", long = TRUE, patient_id = "monkey_id", 
                         baseline_var = "timepoint", baseline_val = 0, 
                         time_var = "timepoint", summary_var = NULL, 
                         responder_var = "clinical_status", sample_id = "sample_id", 
                         project_name = "TB")
```
Please refer to the R help for `desInfo` for more detail on function parameters.

\vspace{12pt}
\begin{center} \large{\textbf{Expression Normalization and Clustering}} \end{center}

Next we generate dendrograms through hierarchical clustering of gene expression data. This step is necessary to produce the heat maps that can be viewed and downloaded in BART. This is done through the `genDendrograms` function, which takes as input the output from `desInfo`. 

```{r}
dendros <- genDendrograms(design_info = des.info)
```
From the output we see that the data was normalized in three different ways, and this is determined by the study design and the information given to `desInfo`. For example, if the study included healthy controls then additional normalizations to healthies would have been included. For more detail on the various normalization methods, please refer to the R help for `genDendgrograms`. 

\vspace{12pt}
\begin{center} \large{\textbf{Generate Gene Set Figures}} \end{center}

It is often of interest to examine the behavior of genes that have been grouped together based on similar biological function or other metric. The `genModules` function calculates the percentage of genes within a gene set that are up or down regulated with respect to baseline and/or a set of controls. These *up* or *down* percentages, referred to as a *gene set scores*, are calculated for every gene set and sample in the study and are plotted within BART as a heatmap. As an example, we formed gene sets by creating a list of 10 clusters determined through hierarchical clustering. The function call to generate the gene set maps is below.

```{r}
mods <- genModules(design_info = des.info, gene_sets = clusters)
```

Refer to the R help for `genModules` for more detail on function parameters and how the gene set scores are calculated. 
\vspace{12pt}
\begin{center} \large{\textbf{Sample Differential Expression Analysis with limma}} \end{center}

Now we demonstrate a quick walkthrough of differential expression analysis of microarray and flow cytometry data using limma. For more details about modeling in limma, refer to the [limma User's Guide](https://www.bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf).


#### Microarray
Create a grouping factor by combining clinical status and time point. 
```{r}
tb.design$Group <- paste(tb.design$clinical_status, tb.design$timepoint, sep = "")
grp <- factor(tb.design$Group)

```
Create a design matrix that includes separate coefficients for each level within the grouping factor so that the desired differences can be extracted as contrasts.
```{r}
design2 <- model.matrix(~0+grp)
colnames(design2) <- levels(grp)
```
Since there are repeated measurements on each monkey, we treat monkey_id as a random effect and estimate the correlation between measurements on the same subject. In limma, this is done using duplicateCorrelation.
```{r}
dupcor <- duplicateCorrelation(tb.expr, design2, block = tb.design$monkey_id)
```
Fit model and extract contrasts of interest.
```{r}
fit <- lmFit(tb.expr, design2, block = tb.design$monkey_id, correlation = dupcor$consensus.correlation)
contrasts <- makeContrasts(A_20vsPre = Active20-Active0, A_42vsPre = Active42-Active0,
                           L_20vsPre = Latent20-Latent0, L_42vsPre = Latent42-Latent0,
                           levels=design2)

fit2 <- contrasts.fit(fit, contrasts)
fit2 <- eBayes(fit2, trend = FALSE)
```


#### Flow Cytometry

Analysis of flow data in limma proceeds similarly.

```{r}
tb.flow.des$Group <- paste(tb.flow.des$clinical_status, tb.flow.des$timepoint, sep = "")
grp <- factor(tb.flow.des$Group)

design2 <- model.matrix(~0+grp)
colnames(design2) <- levels(grp)
dupcor <- duplicateCorrelation(tb.flow, design2, block = tb.flow.des$monkey_id)

fit.flow <- lmFit(tb.flow, design2, block = tb.flow.des$monkey_id, correlation = dupcor$consensus.correlation)

# Add more contrasts since we have all timepoints available. Additional contrasts could be added as well.
contrasts <- makeContrasts(A_20vsPre = Active20-Active0, A_30vsPre = Active30-Active0,
                           A_42vsPre = Active42-Active0, A_56vsPre = Active56-Active0,
                           L_20vsPre = Latent20-Latent0, L_30vsPre = Latent30-Latent0,
                           L_42vsPre = Latent42-Latent0, L_46vsPre = Latent56-Latent0,
                           levels=design2)

fit2.flow <- contrasts.fit(fit.flow, contrasts)
fit2.flow <- eBayes(fit2.flow, trend = FALSE)
```

\vspace{12pt}
\begin{center} \large{\textbf{Generate Model Results File}} \end{center}

The next step in the process is to generate a model results file that is formatted specifically for BART. This can be done by using the `genModelResults` function, which takes as input the results output from `desInfo`, as well as models run in limma, DESeq2, or edgeR. In our example, we are ran limma models on both microarray and flow data.

```{r}
mod_results <- genModelResults(design_info = des.info, object = fit2, lm_Fit = fit, method = "limma")
mod_results.flow <- genModelResults(design_info = des.info.flow, object = fit2.flow, lm_Fit = fit.flow,
                                    method = "limma")
```

\vspace{12pt}
\begin{center} \large{\textbf{Gene Set Analysis: qBart}} \end{center}

Next we run gene set analysis by incorporating functions available in the `qusage` package, which tests whether the average log2 fold change of the genes within a gene set are different than 0. `qBart` simplifies the process by requiring only two input parameters, the model results object produced by `genModelResults` and a list of gene sets.

```{r}
qus <- qBart(object = mod_results, gene_sets = modules)
```

\vspace{12pt}
\begin{center} \large{\textbf{Correlations}} \end{center}

In addition to providing tools for the standard analysis workflow, BART also offers a tool that allows users to visualize and sort through potentially hundreds of thousands pairwise correlations between clinical outcomes. The `crossCorr` function takes two data frames of outcomes and outputs a long format file of all pairwise correlations. We walk through an example in which we wish to correlate module activity scores with flow variables. Since this is a longitudinal setting, we correlate by time.

```{r}
# Create time variable
time <- module.as$time
module.as$time <- NULL

# Format flow data to run correlations and match flow samples with module.as
flow <- data.frame(t(tb.flow))
flow <- flow[match(rownames(module.as), rownames(flow), nomatch = 0), ]

# Run correlations formatted for BART
corrs <- crossCorr(x = module.as, y = flow, by = time, by_name = "days", 
                   description = "Mod.Act.Score vs Flow", x_var = "Mod.Act.Score", 
                   y_var = "Flow", method = "spearman")

```

\vspace{12pt}
\begin{center} \large{\textbf{Generate BART file}} \end{center}

The last step in the process is to generate the final file that can be uploaded into BART. This is done through the function `genFile`, which takes as its arguments the objects generated from the previous functions. Not every object is required to generate a BART file. For example, if gene set analysis and correlations are not run, `desInfo`, `genDendrograms`, `genModules`, and `genModelResults` objects can still be run through `genFile`. BART will only show the results that are uploaded.

```{r}
genFile(design_info = list(des.info, des.info.flow), module_maps = mods, dendros = dendros, 
        model_results = list(mod_results, mod_results.flow))
```

In our example, we did run gene set analysis and correlations. Adding these results into BART is made simple through the `updateFile` function. The user must simply provide the path to the BART file that needs to be updated and add the new additions in the same way that `genFile` takes them.

```{r, eval = FALSE}
path <- paste(getwd(), "/", des.info$project_name, " Pipeline", sep = "")
updateFile(load.path = path, qusage_results = qus, corr_results = list(corrs))
```

\vspace{12pt}
\begin{center} \large{\textbf{Run BART App}} \end{center}

Now that a BART file has been created, it is now time to begin using the app by running the function `runBart`. An in-app vignette is provided that walks through each of the tools BART provides and how to use them.

```{r, eval = FALSE}
runBart()
```
